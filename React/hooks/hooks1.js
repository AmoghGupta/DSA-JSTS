// useState: This hook allows you to manage state in a functional component. You can declare a state variable and a function to update it, and use them in your component.

// useEffect: This hook allows you to perform side effects in a functional component, such as fetching data, subscribing to events, or updating the DOM. You can use it to run code when the component mounts, updates, or unmounts.

// useContext: This hook allows you to access the context in a functional component. You can use it to pass down data and functions to child components without having to pass them through props.

// useReducer: This hook allows you to manage state in a more complex way than useState, using a reducer function. You can use it to update state based on previous state and an action, similar to Redux.

// useRef: This hook allows you to create a mutable ref object that persists for the lifetime of the component. You can use it to access DOM elements, store previous values, or trigger component re-renders.

// useCallback: This hook allows you to memoize a function, so that it only changes when its dependencies change. You can use it to optimize performance by avoiding unnecessary re-renders.

// useMemo: This hook allows you to memoize a value, so that it only changes when its dependencies change. You can use it to optimize performance by avoiding unnecessary recalculations.

// useLayoutEffect: This hook allows you to perform side effects that require access to the DOM before the browser paints. You can use it to update the layout or style of a component immediately, before the user sees it.

// useImperativeHandle: This hook allows you to customize the instance value that is exposed to parent components when using ref. You can use it to expose specific methods or values to the parent component.